# 7주차: REST API 확장 + AOP 기초

**🎯 구현 목표:**

- **RESTful API 어노테이션 확장** (@RestController, @GetMapping, @PostMapping)
- **AOP (Aspect-Oriented Programming)** 기초 - 횡단 관심사 분리

**📋 현재 상황:**

- ✅ 기본 MVC 구조 완성 (@Controller, @RequestMapping)
- ✅ 파라미터 바인딩 (@RequestParam, @PathVariable, @RequestBody)
- ✅ HTTP 메소드별 처리 (GET, POST, PUT, DELETE)
- ✅ JSON 응답 처리

---

## 📚 병행 학습 (20분)

### **핵심 학습 내용:**

- **REST API 원칙** - HTTP 메소드 활용
- **Dynamic Proxy & InvocationHandler** - AOP 구현의 핵심 ⭐⭐⭐
- **Proxy Pattern** - AOP의 기반 디자인 패턴
- **JSON 라이브러리** (Jackson 또는 Gson) 기초

### **추가 자바 개념:**

```java
// Dynamic Proxy - AOP의 핵심 기술
import java.lang.reflect.Proxy;
import java.lang.reflect.InvocationHandler;

public class ProxyFactory {
    public static Object createProxy(Object target) {
        return Proxy.newProxyInstance(
            target.getClass().getClassLoader(),
            target.getClass().getInterfaces(),
            (proxy, method, args) -> {
                // 메소드 실행 전 처리 (AOP)
                System.out.println("Before: " + method.getName());
                Object result = method.invoke(target, args);
                System.out.println("After: " + method.getName());
                return result;
            }
        );
    }
}
```

---

## 🧠 핵심 개념 이해

- **REST API**: Representational State Transfer, HTTP를 잘 활용한 API 설계 원칙
- **AOP (Aspect-Oriented Programming)**: 횡단 관심사(로깅, 보안, 트랜잭션)를 분리하는 프로그래밍 패러다임
- **Cross-cutting Concerns**: 여러 모듈에 걸쳐 나타나는 공통 기능들
- **Dynamic Proxy**: 런타임에 프록시 객체를 생성하여 AOP 구현
- **InvocationHandler**: 프록시 객체의 메소드 호출을 가로채는 핸들러

---

## 💻 구현 내용 (40분)

### **1. REST API 어노테이션 확장**

```java
// 1) @RestController 어노테이션 추가
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface RestController {}

// 2) HTTP 메소드별 단축 어노테이션 추가
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface GetMapping {
    String value();
}

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface PostMapping {
    String value();
}

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface PutMapping {
    String value();
}

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface DeleteMapping {
    String value();
}

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface PatchMapping {
    String value();
}

// 3) 기존 UserController를 REST API 스타일로 확장
@RestController  // 새로운 REST 컨트롤러
public class ApiController {

    @Autowired
    private UserService userService;

    @GetMapping("/api/users")  // 기존 @RequestMapping 대신 단축형
    public String getUsers() {
        return "{\"users\": \"API response\"}";
    }

    @PostMapping("/api/users")
    public String createUser(@RequestBody String user) {
        return "{\"message\": \"User created: " + user + "\"}";
    }

    @PutMapping("/api/users/{id}")
    public String updateUser(@PathVariable("id") Long id, @RequestBody String user) {
        return "{\"message\": \"User " + id + " updated: " + user + "\"}";
    }

    @DeleteMapping("/api/users/{id}")
    public String deleteUser(@PathVariable("id") Long id) {
        return "{\"message\": \"User " + id + " deleted\"}";
    }

    @PatchMapping("/api/users/{id}")
    public String patchUser(@PathVariable("id") Long id, @RequestBody String updates) {
        return "{\"message\": \"User " + id + " partially updated: " + updates + "\"}";
    }
}
```

### **2. AOP 기초 구현 - Dynamic Proxy 활용**

```java
// AOP 기초 - 로깅 어노테이션
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Loggable {}

// Dynamic Proxy를 위한 InvocationHandler 구현
public class LoggingInvocationHandler implements InvocationHandler {
    private final Object target;

    public LoggingInvocationHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // AOP 로직이 들어가는 핵심 부분
        if (method.isAnnotationPresent(Loggable.class)) {
            long start = System.currentTimeMillis();
            System.out.println("=== 메소드 실행 시작: " + method.getName() + " ===");

            Object result = method.invoke(target, args);  // 실제 메소드 실행

            long end = System.currentTimeMillis();
            System.out.println("=== 메소드 실행 완료: " + method.getName() + " (" + (end - start) + "ms) ===");
            return result;
        }
        return method.invoke(target, args);
    }
}

// AOP 프록시 팩토리
public class AopProxyFactory {
    public static <T> T createProxy(T target, Class<T> interfaceType) {
        return (T) Proxy.newProxyInstance(
            target.getClass().getClassLoader(),
            new Class[]{interfaceType},
            new LoggingInvocationHandler(target)
        );
    }
}
```

### **3. 서비스 인터페이스와 구현체 (AOP 적용용)**

```java
// 서비스 인터페이스 (AOP 적용을 위해 인터페이스 필요)
public interface UserService {
    List<User> getAllUsers();
    void saveUser(User user);
}

@Service
public class UserServiceImpl implements UserService {

    @Loggable  // 이 메소드에 AOP 적용
    public List<User> getAllUsers() {
        // 실제 비즈니스 로직
        return Arrays.asList(new User("John"), new User("Jane"));
    }

    @Loggable
    public void saveUser(User user) {
        System.out.println("Saving user: " + user.getName());
    }
}
```

### **4. IoC 컨테이너에 AOP 기능 통합**

```java
public class IoContainer {
    private Map<String, Object> beans = new HashMap<>();

    public void registerBean(String name, Object bean) {
        // 인터페이스가 있으면 AOP 프록시 생성
        Class<?>[] interfaces = bean.getClass().getInterfaces();
        if (interfaces.length > 0) {
            Object proxy = AopProxyFactory.createProxy(bean, interfaces[0]);
            beans.put(name, proxy);  // 프록시를 컨테이너에 등록
            System.out.println("AOP 프록시가 적용된 " + name + " 빈을 등록했습니다.");
        } else {
            beans.put(name, bean);  // 원본 객체 등록
            System.out.println("일반 " + name + " 빈을 등록했습니다.");
        }
    }

    public <T> T getBean(String name, Class<T> type) {
        return type.cast(beans.get(name));
    }
}
```

### **5. 기존 HandlerMapping 확장 (새로운 어노테이션 지원)**

**🔄 기존 구현 분석:**

- 현재 `HandlerMapping.registerController()`에서 `@Controller` + `@RequestMapping` 조합만 처리
- `mappings` Map에 `"HTTP메소드:URL"` 형태로 저장
- 기존 로직을 건드리지 않고 새로운 어노테이션 지원 추가

**🎯 확장 전략:**

```java
// 기존 HandlerMapping.java의 registerController() 메소드 확장
public void registerController(Object controller) {
    Class<?> clazz = controller.getClass();

    // 1) 기존 @Controller 처리 (기존 코드 유지)
    if (clazz.isAnnotationPresent(Controller.class)){
        registerRequestMappingMethods(controller, clazz);
    }

    // 2) 새로운 @RestController 처리 (신규 추가)
    if (clazz.isAnnotationPresent(RestController.class)){
        registerRestControllerMethods(controller, clazz);
    }
}

// 기존 @RequestMapping 처리 로직 (변경 없음)
private void registerRequestMappingMethods(Object controller, Class<?> clazz) {
    Method[] methods = clazz.getDeclaredMethods();
    for (Method method : methods) {
        if (method.isAnnotationPresent(RequestMapping.class)){
            RequestMapping mapping = method.getAnnotation(RequestMapping.class);
            String url = mapping.value();
            RequestMethod httpMethod = mapping.method();

            String mappingKey = httpMethod.name() + ":" + url;
            HandlerMethod handlerMethod = new HandlerMethod(controller, method);
            mappings.put(mappingKey, handlerMethod);

            System.out.println("✅ @RequestMapping 등록: " + url + " -> " + handlerMethod);
        }
    }
}

// 새로운 @GetMapping, @PostMapping 처리 로직
private void registerRestControllerMethods(Object controller, Class<?> clazz) {
    Method[] methods = clazz.getDeclaredMethods();
    for (Method method : methods) {
        String mappingKey = null;
        String url = null;

        // @GetMapping 처리
        if (method.isAnnotationPresent(GetMapping.class)) {
            GetMapping mapping = method.getAnnotation(GetMapping.class);
            url = mapping.value();
            mappingKey = "GET:" + url;
        }
        // @PostMapping 처리
        else if (method.isAnnotationPresent(PostMapping.class)) {
            PostMapping mapping = method.getAnnotation(PostMapping.class);
            url = mapping.value();
            mappingKey = "POST:" + url;
        }

        if (mappingKey != null) {
            HandlerMethod handlerMethod = new HandlerMethod(controller, method);
            mappings.put(mappingKey, handlerMethod);
            System.out.println("✅ REST API 매핑 등록: " + url + " -> " + handlerMethod);
        }
    }
}
```

**📋 WebApplicationContext 확장:**

```java
// WebApplicationContext에서 컨트롤러 스캔 시 @RestController도 인식
public void scanAndRegisterControllers() {
    List<Object> allControllers = new ArrayList<>();

    // 기존 @Controller 스캔
    allControllers.addAll(componentScanner.findAnnotatedClasses(Controller.class));

    // 새로운 @RestController 스캔 (추가)
    allControllers.addAll(componentScanner.findAnnotatedClasses(RestController.class));

    handlerMapping.scanControllers(allControllers);
}
```

---

## 🔗 기존 구현과의 연결점

### **1. 기존 아키텍처 활용**

- **DispatcherServlet**: 기본 요청 처리 흐름 유지
- **HandlerMapping**: 기존 `mappings` Map 구조 그대로 활용
- **HandlerMethod**: 기존 클래스 재사용
- **WebApplicationContext**: 컨트롤러 스캔 로직 확장

### **2. 호환성 보장**

- **기존 UserController**: `@Controller` + `@RequestMapping` 그대로 동작
- **새로운 ApiController**: `@RestController` + `@GetMapping` 추가 지원
- **동시 사용 가능**: 같은 애플리케이션에서 두 방식 모두 사용

### **3. 확장 포인트**

```java
// 기존: src/main/java/com/melt/web/mapping/HandlerMapping.java
public void registerController(Object controller) {
    // 기존 로직 + 새로운 로직 추가
}

// 기존: src/main/java/com/melt/web/context/WebApplicationContext.java
public void refresh() {
    // 기존 컴포넌트 스캔 + @RestController 스캔 추가
}
```

---

## 📝 구현 순서 (7일 계획)

### **Day 1-2**: Dynamic Proxy & InvocationHandler 학습 및 기초 구현

- `Proxy.newProxyInstance()` 사용법 익히기
- `InvocationHandler` 구현해보기
- 간단한 로깅 프록시 만들어보기

### **Day 3-4**: REST API 어노테이션 추가

- `@RestController`, `@GetMapping`, `@PostMapping` 어노테이션 정의
- 기존 `@RequestMapping`과 병행 사용 가능하게 구현

### **Day 5**: 기존 HandlerMapping 확장

- **기존 `HandlerMapping.registerController()` 메소드 확장**
  - `registerRequestMappingMethods()` 메소드로 기존 로직 분리
  - `registerRestControllerMethods()` 메소드 추가
- **WebApplicationContext에서 `@RestController` 스캔 추가**
- **기존 `@Controller` + `@RequestMapping` 과 호환성 유지**

### **Day 6**: AOP와 IoC 컨테이너 통합

- 컨테이너에서 빈 등록 시 자동으로 AOP 프록시 생성
- `@Loggable` 어노테이션 적용된 메소드에 로깅 기능 동작

### **Day 7**: 통합 테스트

- **ApiController 생성 및 전체 기능 테스트**
  - `@RestController` + `@GetMapping` 조합 테스트
  - 기존 `UserController`와 새로운 `ApiController` 동시 동작 확인
- **브라우저에서 `/api/users` 요청 시 JSON 응답 확인**
- **AOP 로깅이 제대로 동작하는지 확인**
- **기존 `/users/{id}` 엔드포인트와의 호환성 확인**

---

## 🎯 이번 주 최소 달성 목표

### **✅ 반드시 해야 할 것:**

1. **브라우저에서 `/api/users` GET 요청 시 JSON 응답 받기**
2. **`@RestController`, `@GetMapping` 어노테이션 동작 확인**
3. **`@Loggable` 어노테이션 붙은 메소드 실행 시 콘솔에 로그 출력 확인**
4. **기존 `/users/{id}` 엔드포인트가 여전히 정상 동작하는지 확인** ⭐

### **🔄 호환성 검증:**

- 기존 `UserController` (`@Controller` + `@RequestMapping`) 정상 동작
- 새로운 `ApiController` (`@RestController` + `@GetMapping`) 정상 동작
- 두 컨트롤러가 동시에 문제없이 작동

### **⭐ 도전 과제 (시간 여유 있으면):**

- POST 요청으로 데이터 생성 API 만들어보기
- 다양한 REST 엔드포인트 추가해보기
- AOP에 다른 기능(실행 시간 측정 외) 추가해보기

---

## 🔑 학습 키워드

- **REST API** ⭐⭐⭐
- **AOP (Aspect-Oriented Programming)** ⭐⭐⭐
- **Dynamic Proxy & InvocationHandler** ⭐⭐⭐
- **@RestController**, **@GetMapping**, **@PostMapping**
- **Cross-cutting Concerns**, **Proxy Pattern**
- **JSON 직렬화/역직렬화**
- `Proxy.newProxyInstance()`, `Method.invoke()`

---

## 💡 실용적 팁

### **시간 절약을 위한 접근:**

- **복잡한 AOP 구현은 스킵**: CGLIB, AspectJ 문법 제외
- **핵심만 구현**: 간단한 Dynamic Proxy만
- **Method-level Annotation 기반**으로만 AOP 적용
- **완벽보다는 동작**에 초점

### **프론트엔드 경험 활용:**

- **API 호출 방식**은 이미 아실 테니, 서버 쪽 구현에 집중
- **JSON 구조**도 익숙하실 것 같아요
- **HTTP 메소드** (GET, POST 등) 개념도 아실 테니 구현만 하시면 됩니다!

**Dynamic Proxy**만 제대로 이해하시면 나머지는 응용이니까, 이것부터 시작해보세요! 🚀
