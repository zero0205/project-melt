# 7주차: REST API 확장

**🎯 구현 목표:**

- **RESTful API 어노테이션 확장** (@RestController, @GetMapping, @PostMapping, @PutMapping, @DeleteMapping, @PatchMapping)

**📋 현재 상황:**

- ✅ 기본 MVC 구조 완성 (@Controller, @RequestMapping)
- ✅ 파라미터 바인딩 (@RequestParam, @PathVariable, @RequestBody)
- ✅ HTTP 메소드별 처리 (GET, POST, PUT, DELETE)
- ✅ JSON 응답 처리

---

## 📚 개념 학습 (개별 진행)

### **AOP 핵심 개념 (개별 학습):**

- **AOP (Aspect-Oriented Programming)**: 횡단 관심사(로깅, 보안, 트랜잭션)를 분리하는 프로그래밍 패러다임
- **Dynamic Proxy & InvocationHandler** - AOP 구현의 핵심 ⭐⭐⭐
- **Proxy Pattern** - AOP의 기반 디자인 패턴
- **Cross-cutting Concerns**: 여러 모듈에 걸쳐 나타나는 공통 기능들

### **구현 중심 학습:**

- **REST API 원칙** - HTTP 메소드 활용
- **RESTful 어노테이션** (@RestController, @GetMapping 등)
- **JSON 응답 처리**

---

## 🧠 핵심 개념 이해

- **REST API**: Representational State Transfer, HTTP를 잘 활용한 API 설계 원칙
- **@RestController**: JSON 응답을 기본으로 하는 컨트롤러
- **HTTP Method Mapping**: 각 HTTP 메소드별 전용 어노테이션 (@GetMapping, @PostMapping 등)

---

## 💻 구현 내용

### **1. REST API 어노테이션 확장**

```java
// 1) @RestController 어노테이션 추가
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface RestController {}

// 2) HTTP 메소드별 단축 어노테이션 추가
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface GetMapping {
    String value();
}

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface PostMapping {
    String value();
}

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface PutMapping {
    String value();
}

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface DeleteMapping {
    String value();
}

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface PatchMapping {
    String value();
}

// 3) 기존 UserController를 REST API 스타일로 확장
@RestController  // 새로운 REST 컨트롤러
public class ApiController {

    @Autowired
    private UserService userService;

    @GetMapping("/api/users")  // 기존 @RequestMapping 대신 단축형
    public String getUsers() {
        return "{\"users\": \"API response\"}";
    }

    @PostMapping("/api/users")
    public String createUser(@RequestBody String user) {
        return "{\"message\": \"User created: " + user + "\"}";
    }

    @PutMapping("/api/users/{id}")
    public String updateUser(@PathVariable("id") Long id, @RequestBody String user) {
        return "{\"message\": \"User " + id + " updated: " + user + "\"}";
    }

    @DeleteMapping("/api/users/{id}")
    public String deleteUser(@PathVariable("id") Long id) {
        return "{\"message\": \"User " + id + " deleted\"}";
    }

    @PatchMapping("/api/users/{id}")
    public String patchUser(@PathVariable("id") Long id, @RequestBody String updates) {
        return "{\"message\": \"User " + id + " partially updated: " + updates + "\"}";
    }
}
```

### **2. 기존 HandlerMapping 확장 (새로운 어노테이션 지원)**

**🔄 기존 구현 분석:**

- 현재 `HandlerMapping.registerController()`에서 `@Controller` + `@RequestMapping` 조합만 처리
- `mappings` Map에 `"HTTP메소드:URL"` 형태로 저장
- 기존 로직을 건드리지 않고 새로운 어노테이션 지원 추가

**🎯 확장 전략:**

```java
// 기존 HandlerMapping.java의 registerController() 메소드 확장
public void registerController(Object controller) {
    Class<?> clazz = controller.getClass();

    // 1) 기존 @Controller 처리 (기존 코드 유지)
    if (clazz.isAnnotationPresent(Controller.class)){
        registerRequestMappingMethods(controller, clazz);
    }

    // 2) 새로운 @RestController 처리 (신규 추가)
    if (clazz.isAnnotationPresent(RestController.class)){
        registerRestControllerMethods(controller, clazz);
    }
}

// 기존 @RequestMapping 처리 로직 (변경 없음)
private void registerRequestMappingMethods(Object controller, Class<?> clazz) {
    Method[] methods = clazz.getDeclaredMethods();
    for (Method method : methods) {
        if (method.isAnnotationPresent(RequestMapping.class)){
            RequestMapping mapping = method.getAnnotation(RequestMapping.class);
            String url = mapping.value();
            RequestMethod httpMethod = mapping.method();

            String mappingKey = httpMethod.name() + ":" + url;
            HandlerMethod handlerMethod = new HandlerMethod(controller, method);
            mappings.put(mappingKey, handlerMethod);

            System.out.println("✅ @RequestMapping 등록: " + url + " -> " + handlerMethod);
        }
    }
}

// 새로운 @GetMapping, @PostMapping 처리 로직
private void registerRestControllerMethods(Object controller, Class<?> clazz) {
    Method[] methods = clazz.getDeclaredMethods();
    for (Method method : methods) {
        String mappingKey = null;
        String url = null;

        // @GetMapping 처리
        if (method.isAnnotationPresent(GetMapping.class)) {
            GetMapping mapping = method.getAnnotation(GetMapping.class);
            url = mapping.value();
            mappingKey = "GET:" + url;
        }
        // @PostMapping 처리
        else if (method.isAnnotationPresent(PostMapping.class)) {
            PostMapping mapping = method.getAnnotation(PostMapping.class);
            url = mapping.value();
            mappingKey = "POST:" + url;
        }
        // @PutMapping 처리
        else if (method.isAnnotationPresent(PutMapping.class)) {
            PutMapping mapping = method.getAnnotation(PutMapping.class);
            url = mapping.value();
            mappingKey = "PUT:" + url;
        }
        // @DeleteMapping 처리
        else if (method.isAnnotationPresent(DeleteMapping.class)) {
            DeleteMapping mapping = method.getAnnotation(DeleteMapping.class);
            url = mapping.value();
            mappingKey = "DELETE:" + url;
        }
        // @PatchMapping 처리
        else if (method.isAnnotationPresent(PatchMapping.class)) {
            PatchMapping mapping = method.getAnnotation(PatchMapping.class);
            url = mapping.value();
            mappingKey = "PATCH:" + url;
        }

        if (mappingKey != null) {
            HandlerMethod handlerMethod = new HandlerMethod(controller, method);
            mappings.put(mappingKey, handlerMethod);
            System.out.println("✅ REST API 매핑 등록: " + url + " -> " + handlerMethod);
        }
    }
}
```

**📋 WebApplicationContext 확장:**

```java
// WebApplicationContext에서 컨트롤러 스캔 시 @RestController도 인식
public void scanAndRegisterControllers() {
    List<Object> allControllers = new ArrayList<>();

    // 기존 @Controller 스캔
    allControllers.addAll(componentScanner.findAnnotatedClasses(Controller.class));

    // 새로운 @RestController 스캔 (추가)
    allControllers.addAll(componentScanner.findAnnotatedClasses(RestController.class));

    handlerMapping.scanControllers(allControllers);
}
```

---

## 🔗 기존 구현과의 연결점

### **1. 기존 아키텍처 활용**

- **DispatcherServlet**: 기본 요청 처리 흐름 유지
- **HandlerMapping**: 기존 `mappings` Map 구조 그대로 활용
- **HandlerMethod**: 기존 클래스 재사용
- **WebApplicationContext**: 컨트롤러 스캔 로직 확장

### **2. 호환성 보장**

- **기존 UserController**: `@Controller` + `@RequestMapping` 그대로 동작
- **새로운 ApiController**: `@RestController` + `@GetMapping` 추가 지원
- **동시 사용 가능**: 같은 애플리케이션에서 두 방식 모두 사용

### **3. 확장 포인트**

```java
// 기존: src/main/java/com/melt/web/mapping/HandlerMapping.java
public void registerController(Object controller) {
    // 기존 로직 + 새로운 로직 추가
}

// 기존: src/main/java/com/melt/web/context/WebApplicationContext.java
public void refresh() {
    // 기존 컴포넌트 스캔 + @RestController 스캔 추가
}
```

---

## 🎯 이번 주 최소 달성 목표

### **✅ 반드시 해야 할 것:**

1. **브라우저에서 `/api/users` GET 요청 시 JSON 응답 받기**
2. **`@RestController`, `@GetMapping` 어노테이션 동작 확인**
3. **`@Loggable` 어노테이션 붙은 메소드 실행 시 콘솔에 로그 출력 확인**
4. **기존 `/users/{id}` 엔드포인트가 여전히 정상 동작하는지 확인** ⭐

### **🔄 호환성 검증:**

- 기존 `UserController` (`@Controller` + `@RequestMapping`) 정상 동작
- 새로운 `ApiController` (`@RestController` + `@GetMapping`) 정상 동작
- 두 컨트롤러가 동시에 문제없이 작동

### **⭐ 도전 과제 (시간 여유 있으면):**

- POST 요청으로 데이터 생성 API 만들어보기
- 다양한 REST 엔드포인트 추가해보기

---

## 🔑 학습 키워드

- **REST API** ⭐⭐⭐
- **AOP (Aspect-Oriented Programming)** ⭐⭐⭐
- **Dynamic Proxy & InvocationHandler** ⭐⭐⭐
- **@RestController**, **@GetMapping**, **@PostMapping**
- **Cross-cutting Concerns**, **Proxy Pattern**
- **JSON 직렬화/역직렬화**
- `Proxy.newProxyInstance()`, `Method.invoke()`
