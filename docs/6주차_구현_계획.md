# 📋 6주차: HTTP 요청 데이터 처리 구현

## 🎯 수정된 목표

- **HTTP 요청 데이터 완전 처리**: GET/POST/PUT/DELETE 모든 요청 타입 지원
- **Spring MVC 핵심 어노테이션** 구현: `@RequestParam`, `@PathVariable`, `@RequestBody`
- **파라미터 바인딩**: 문자열 → Java 객체 자동 변환
- **실제 동작 검증**: Postman/브라우저로 모든 케이스 테스트

---

## 📚 병행 학습 (20분)

### **핵심 개념 이해:**

- **HTTP 요청의 3가지 데이터 전달 방식**
  - Query Parameter: `?name=john&age=25`
  - Path Variable: `/users/123`
  - Request Body: JSON, Form 데이터
- **Java 타입 변환** (`String` → `int`, `Long` 등)
- **JSON 파싱** 기초
- **HTTP 메소드별 특성** (GET은 Body 없음, POST는 Body 있음)

### **Java 기술:**

- `HttpServletRequest.getParameter()`
- `HttpServletRequest.getInputStream()` (RequestBody용)
- **정규표현식** 기초 (URL 패턴 매칭용)
- **Jackson 라이브러리** 또는 간단한 JSON 파싱

---

## 💻 구현 내용 (40분)

### **1단계: 어노테이션 정의 (5분)**

```java
// RequestMethod enum (이미 존재함)
enum RequestMethod {
    GET, POST, PUT, DELETE
}

// RequestMapping (이미 존재함)
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RequestMapping {
    String value();
    RequestMethod method() default RequestMethod.GET;
}

// 파라미터 처리 어노테이션
@Target(ElementType.PARAMETER)
@Retention(RetentionPolicy.RUNTIME)
public @interface RequestParam {
    String value();
    boolean required() default true;
}

@Target(ElementType.PARAMETER)
@Retention(RetentionPolicy.RUNTIME)
public @interface PathVariable {
    String value();
}

@Target(ElementType.PARAMETER)
@Retention(RetentionPolicy.RUNTIME)
public @interface RequestBody {
}

```

### **2단계: URL 패턴 매칭 강화 (10분)**

```java
// URL 패턴과 실제 URL 매칭하는 유틸리티
public class UrlMatcher {

    // /users/{id} 패턴과 /users/123 실제 URL 매칭
    public static boolean matches(String pattern, String url) {
        String regex = pattern.replaceAll("\\{[^}]+\\}", "([^/]+)");
        // /users/{id} → /users/([^/]+) 정규표현식으로 변환
        return url.matches(regex);
    }

    // 실제 URL에서 PathVariable 값 추출
    public static Map<String, String> extractPathVariables(String pattern, String url) {
        Map<String, String> variables = new HashMap<>();

        // {id} 같은 변수명 찾기
        Pattern varPattern = Pattern.compile("\\{([^}]+)\\}");
        Matcher varMatcher = varPattern.matcher(pattern);

        // 실제 값 추출하는 정규표현식
        String regex = pattern.replaceAll("\\{[^}]+\\}", "([^/]+)");
        Pattern urlPattern = Pattern.compile(regex);
        Matcher urlMatcher = urlPattern.matcher(url);

        if (urlMatcher.matches()) {
            int groupIndex = 1;
            varMatcher.reset();
            while (varMatcher.find()) {
                String varName = varMatcher.group(1); // {id}에서 id 추출
                String value = urlMatcher.group(groupIndex++); // 실제 값
                variables.put(varName, value);
            }
        }

        return variables;
    }
}

```

### **3단계: HandlerMapping 강화 (15분)**

```java
public class HandlerMapping {
    private final Map<String, HandlerMethod> mappings = new HashMap<>();

    // URL 패턴 매칭을 위한 개선된 getHandler 메소드
    public HandlerMethod getHandler(String url, String httpMethod) {
        // 1. 정확한 매칭 먼저 시도
        String mappingKey = httpMethod + ":" + url;
        HandlerMethod handler = mappings.get(mappingKey);
        if (handler != null) {
            return handler;
        }

        // 2. PathVariable이 있는 패턴 매칭
        for (Map.Entry<String, HandlerMethod> entry : mappings.entrySet()) {
            String key = entry.getKey();
            if (key.startsWith(httpMethod + ":")) {
                String pattern = key.substring(httpMethod.length() + 1);
                if (UrlMatcher.matches(pattern, url)) {
                    return entry.getValue();
                }
            }
        }
        return null;
    }

    // 🔥 핵심 로직: 메소드 파라미터 자동 준비
    public Object[] prepareMethodArguments(HandlerMethod handler,
                                          HttpServletRequest req, String uri) throws Exception {

        Method method = handler.getMethod();
        Parameter[] parameters = method.getParameters();
        Object[] args = new Object[parameters.length];

        // PathVariable 값들 미리 추출
        String urlPattern = getUrlPattern(handler);
        Map<String, String> pathVars = UrlMatcher.extractPathVariables(urlPattern, uri);

        for (int i = 0; i < parameters.length; i++) {
            Parameter param = parameters[i];

            if (param.isAnnotationPresent(RequestParam.class)) {
                // @RequestParam 처리
                RequestParam annotation = param.getAnnotation(RequestParam.class);
                String paramName = annotation.value();
                String paramValue = req.getParameter(paramName);

                args[i] = convertToType(paramValue, param.getType());

            } else if (param.isAnnotationPresent(PathVariable.class)) {
                // @PathVariable 처리
                PathVariable annotation = param.getAnnotation(PathVariable.class);
                String varName = annotation.value();
                String varValue = pathVars.get(varName);

                args[i] = convertToType(varValue, param.getType());

            } else if (param.isAnnotationPresent(RequestBody.class)) {
                // @RequestBody 처리 (JSON)
                String jsonBody = readRequestBody(req);
                args[i] = parseJson(jsonBody, param.getType());
            }
        }

        return args;
    }

    // HandlerMethod에서 URL 패턴 추출
    private String getUrlPattern(HandlerMethod handler) {
        Method method = handler.getMethod();
        if (method.isAnnotationPresent(RequestMapping.class)) {
            RequestMapping mapping = method.getAnnotation(RequestMapping.class);
            return mapping.value();
        }
        return "";
    }

    // 타입 변환 유틸리티
    private Object convertToType(String value, Class<?> targetType) {
        if (value == null) return null;

        if (targetType == String.class) return value;
        if (targetType == Integer.class || targetType == int.class)
            return Integer.parseInt(value);
        if (targetType == Long.class || targetType == long.class)
            return Long.parseLong(value);
        if (targetType == Boolean.class || targetType == boolean.class)
            return Boolean.parseBoolean(value);

        return value; // 기본값
    }

    // Request Body 읽기
    private String readRequestBody(HttpServletRequest req) throws IOException {
        StringBuilder sb = new StringBuilder();
        try (BufferedReader reader = req.getReader()) {
            String line;
            while ((line = reader.readLine()) != null) {
                sb.append(line);
            }
        }
        return sb.toString();
    }

    // 간단한 JSON 파싱 (실제로는 Jackson 사용)
    private Object parseJson(String json, Class<?> targetType) {
        // 매우 간단한 User 클래스용 JSON 파싱
        if (targetType.getSimpleName().equals("User")) {
            // 실제로는 User 객체를 생성해야 하지만 여기서는 JSON 문자열 반환
            return json;
        }
        return json; // 기본적으로 JSON 문자열 반환
    }
}
```

### **4단계: DispatcherServlet 단순화 (5분)**

```java
// 기존 DispatcherServlet 수정 - service 메소드만 강화
@Override
protected void service(HttpServletRequest req, HttpServletResponse resp)
        throws ServletException, IOException {

    String httpMethod = req.getMethod();  // GET, POST, PUT, DELETE
    String uri = req.getRequestURI();     // /users/123

    System.out.println("📥 요청: " + httpMethod + " " + uri);

    // HandlerMapping에서 적절한 핸들러 찾기
    HandlerMethod handler = handlerMapping.getHandler(uri, httpMethod);

    if (handler == null) {
        resp.setStatus(HttpServletResponse.SC_NOT_FOUND);
        resp.getWriter().write("Handler not found for: " + httpMethod + " " + uri);
        return;
    }

    try {
        System.out.println("🎯 핸들러 실행: " + httpMethod + " " + handler);

        // HandlerMapping에게 파라미터 준비 위임
        Object[] methodArgs = handlerMapping.prepareMethodArguments(handler, req, uri);

        // 컨트롤러 메소드 실행
        Object result = handler.getMethod().invoke(handler.getController(), methodArgs);

        // JSON 응답으로 설정
        resp.setContentType("application/json;charset=UTF-8");
        resp.getWriter().write(String.valueOf(result));

    } catch (Exception e) {
        System.err.println("❌ 핸들러 실행 오류: " + e.getMessage());
        resp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        resp.getWriter().write("Internal Server Error: " + e.getMessage());
    }
}
```

### **5단계: 테스트용 컨트롤러 (5분)**

```java
@Controller
public class UserController {

    // 간단한 User DTO 클래스 (내부 클래스로 정의)
    public static class User {
        private String name;
        private int age;

        public String getName() { return name; }
        public void setName(String name) { this.name = name; }
        public int getAge() { return age; }
        public void setAge(int age) { this.age = age; }

        @Override
        public String toString() {
            return "User{name='" + name + "', age=" + age + "}";
        }
    }

    // 1. RequestParam 테스트
    @RequestMapping(value = "/users", method = RequestMethod.GET)
    public String getUsers(@RequestParam("name") String name,
                          @RequestParam("age") int age) {
        return "{\"message\": \"Found user: " + name + ", age: " + age + "\"}";
    }

    // 2. PathVariable 테스트
    @RequestMapping(value = "/users/{id}", method = RequestMethod.GET)
    public String getUserById(@PathVariable("id") Long id) {
        return "{\"message\": \"User ID: " + id + "\"}";
    }

    // 3. RequestBody 테스트
    @RequestMapping(value = "/users", method = RequestMethod.POST)
    public String createUser(@RequestBody String user) {
        return "{\"message\": \"Created user: " + user + "\"}";
    }

    // 4. 복합 테스트 (PathVariable + RequestParam)
    @RequestMapping(value = "/users/{id}", method = RequestMethod.PUT)
    public String updateUser(@PathVariable("id") Long id,
                           @RequestParam("status") String status) {
        return "{\"message\": \"Updated user " + id + " to " + status + "\"}";
    }

    // 5. 기본 DELETE 테스트
    @RequestMapping(value = "/users/{id}", method = RequestMethod.DELETE)
    public String deleteUser(@PathVariable("id") Long id) {
        return "{\"message\": \"Deleted user " + id + "\"}";
    }
}


```

---

## 🧪 테스트 케이스 (매일 확인)

### **브라우저 테스트:**

```bash
# 1. RequestParam 테스트
GET http://localhost:8080/users?name=john&age=25

# 2. PathVariable 테스트
GET http://localhost:8080/users/123

```

### **Postman 테스트:**

```bash
# 3. RequestBody 테스트
POST http://localhost:8080/users
Content-Type: application/json
{
  "name": "john",
  "age": 25
}

# 4. 복합 테스트
PUT http://localhost:8080/users/123?status=active

# 5. DELETE 테스트
DELETE http://localhost:8080/users/123

```

### **예상 응답:**

```json
// Case 1
{"message": "Found user: john, age: 25"}

// Case 2
{"message": "User ID: 123"}

// Case 3
{"message": "Created user: john"}

// Case 4
{"message": "Updated user 123 to active"}

// Case 5
{"message": "Deleted user 123"}

```

---

## 🔑 주요 학습 키워드

### **필수 (⭐⭐⭐)**

- **@RequestParam, @PathVariable, @RequestBody**
- **HTTP Method 구분** (GET, POST, PUT, DELETE)
- **URL 패턴 매칭** (정규표현식)
- **파라미터 타입 변환** (String → int, Long)

### **중요 (⭐⭐)**

- **JSON 파싱** 기초
- **Request Body 읽기** (`BufferedReader`)
- **HTTP 요청/응답** 구조

---

## 🎯 주차 완료 기준

### **✅ 체크리스트:**

- [ ] `GET /users?name=john&age=25` 동작
- [ ] `GET /users/123` 동작
- [ ] `POST /users` + JSON Body 동작
- [ ] `PUT /users/123?status=active` 동작
- [ ] `DELETE /users/123` 동작
- [ ] 모든 파라미터 타입 변환 정상 작동
- [ ] 에러 상황 처리 (파라미터 누락, 타입 오류 등)
